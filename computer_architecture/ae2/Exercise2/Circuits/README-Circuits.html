<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-09-17 Sun 18:25 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Circuits for Computer Systems</title>
<meta name="author" content="John T. O'Donnell" />
<meta name="generator" content="Org Mode" />
<!-- Custom html exporter (init.el):
 org-source-file=c:/Users/johnt/OneDrive/home/docs/Sigma/src/csbook/src/Appendices/README-Circuits/README-Circuits.org
 css-style-file=c:/Users/johnt/OneDrive/home/texmf/css/csbook.css
 -->
<style type="text/css">
<!--/*--><![CDATA[/*><!--*/
/* cssbook.css */
/* experiment
div.table-of-contents h2 {
    color: red;
}
div.table-of-contents.h2:after {
    content: "This in new toc header";
}
*/

/* for org export to html, the init.el file has elisp code to generate
manual header entries which appear before the table of contents, as
they should */

div.boxnote {
    border: solid; border-width: thin; border-color: red;
    padding-left: 1em; padding-right: 1em;
    padding-top: .5em; padding-bottom: .5em;
    }

div#preamble booktitle {
    padding-top: 0.5em;
    display:block;
    text-align: center;
    color: #0000ff;
    font-family: verdana;
    font-size: 140%;
    line-height:100%;
    padding-bottom: 0em;
}

filetitle {
    padding-top: 0.1em;
    display:block;
    text-align: center;
    color: #0000ff;
    font-family: verdana;
    font-size: 140%;
    line-height:110%;
    padding-bottom: 0.5em;
}

/* these are used for Sigma16 User Guide but not for csbook */
doctitle, S16version {
    display: none;
}

bookauthor, date {
    display: block;
    padding-top: 0.2em;
    padding-bottom: 0.1em;
    text-align: center;
    font-family: verdana;
    font-size: 110%;
    line-height:105%;
    color: #0000ff;
}

/*
date {
    padding-top: 0.1em;
    padding-bottom: 0.1em;
    display:block;
    text-align: center;
    color: #0000ff;
    font-family: Verdana, sans-serif;
    font-size: 0.95em;
    font-weight: normal;
    line-height: 130%;
}
*/

footitle {
    border: solid; border-width: thin; border-color: green;
    padding-top: 0.2em;
    padding-bottom: 0.2em;
    text-align: center;
    color: blue;
    font-family: Verdana, sans-serif;
    font-size: 1.5em;
    font-weight: normal;
    line-height: 150%;
}

/*
div.ManualTitle {
    border: solid; border-width: thin; border-color: red;
    padding-top: 0.2em;
    padding-bottom: 0.2em;
    text-align: center;
    color: blue;
    font-family: Verdana, sans-serif;
    font-size: 1.5em;
    font-weight: normal;
    line-height: 150%;
}
*/

div.ManualAuthor {
    padding-top: 1em;
    text-align: center;
    color: black;
    font-family: Verdana, sans-serif;
    font-size: 1.05em;
    font-weight: normal;
    line-height: 130%;
}

div.ManualDate {
    padding-top: 0.3em;
    text-align: center;
    color: black;
    font-family: Verdana, sans-serif;
    font-size: 1.05em;
    font-weight: normal;
    line-height: 130%;
}

div.ManualModDate {
    display: none;
    text-align: center;
    color: black;
    font-family: Verdana, sans-serif;
    font-size: 1em;
}

/* Format the html postamble */
p.PostambleTitle, p.PostambleAuthor, p.PostambleEmail,
p.PostambleDate, p.PostambleGenerator {
    text-align: left;
    font-family: Verdana, sans-serif;
    color: blue;
    font-size: 0.9em;
}

/* Disable the default title generated by org, which appears in the
   wrong place
h1.title {
    display: none;
}
*/

body {
    margin: auto;
    max-width: 38em;
    padding-right: 0.5em;
    padding-left: 0.5em;
    color: black;
    font-family: Verdana, sans-serif;
    font-size: 12pt;
    line-height: 140%;
    }
/*
    max-width: 45em;  a little too wide 
    font-size: 100%; */
    border-left: 1px solid black;
    border-right: 1px solid black;
*/

pre {
    border: 1px dotted gray;
    color: black;  
    padding: 1em;
}

code {
    font-family: monospace;
    font-size: 13pt;
    }

.quickstartbox {
    line-height: 2.5;
}

pre.example {
    background-color: #e6ffff; /* light blue background */
    color: black;
}

pre.src-sigma16 {
    background-color: #e6fff2; /* light green background */
    color: black;
}

pre.src-hydra {
    background-color: #ffffe6; /* light yellow background */
    color: black;
}

div#postamble * {
    color: #0000ff;
    font-family: verdana;
    font-size: 90%;
    text-align: left;
}

h1 {
    border: solid; border-width: thin; border-color: red;
    padding-top: 0.5em;
    text-align: center;
    color: #0000ff;
    font-family: verdana;
    font-size: 150%;
    line-height:150%;
    padding-bottom: 0.5em;
}
/*     background: #ddeedd; */
/*     font-weight: bold; */

h2 {
    padding-top: 0.5em;
    text-align: left;
    font-weight: normal;
    font-size: 140%;
    font-weight: bold;
    color: blue;
   }

h3 {
    padding-top: 0.5em;
    text-align: left;
    font-weight: normal;
    font-size: 120%;
    color: blue;
}

h4 {
    padding-top: 0.5em;
    text-align: left;
    font-weight: normal;
    font-size: 105%;
    color: blue;
}

h5 {
    padding-top: 0.5em;
    text-align: left;
    font-weight: normal;
    font-size: 105%;
    color: blue;
}

/*
dt code {
        font-weight: bold;
}
*/
dd p {
        margin-top: 0;
}

footer {
        padding-top: 1em;
        font-size: 70%;
        color: gray;
        text-align: center;
}

  img {
    padding-left: 0em; padding-right: 0em;
    padding-top: 0em; padding-bottom: 0em;
    }

A:link    { color: #0000e0; text-decoration: none }
A:visited { color: #0000a0; text-decoration: none }
A:hover   { background-color: #e0e0ff; text-decoration: none }

h2.author {
  text-align: center;
  font-size: 110%;}

h3.date {
 text-align: center;
  font-size: 100%;}
}

div.titletemp {
    color: navy;
}  

  div.box {
    border: solid; border-width: thin; border-color: red;
    padding-left: 1em; padding-right: 1em;
    padding-top: .5em; padding-bottom: .5em;
    }

  div.color {
    background: yellow;
    padding: 0.5em;
    border: none;
    }

  div.floatright {
    float: right;
    margin: 0 0 10px 10px;
    }

  div.floatleft {
    float: left;
    margin: 0 0 10px 10px;
    }

.floatright {
    border : dotted; border-width: thin; border-color: red;
    padding-left: 1em; padding-right: 1em;
    padding-top: 1em; padding-bottom: 1em;
}


.clearit {
  clear: both;
  }

.figure {
  text-align: center;
  margin-top: 2em;
  margin-bottom: 2em;
  padding: 0em;
  }

/* For Sigma16 homepage */
div.quickstartbox {
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 4em;
    margin-right: 4em;
    border: solid;
    border-width: medium;
    border-color: red;
    padding-left: 1em; padding-right: 1em;
    padding-top: 0.75em; padding-bottom: 0.75em;
    font-size: 170%;
    line-height: 120%;
    text-align: center;
    }

VersionText {
   font-size: 120%;
}

/*
The following contains parts of Sigma16 style that differ from Hydra style

html {
    width: 100%;
    color: black;
    background: white;
    font-family: Verdana, sans-serif;
    font-size: 0.8em;
    line-height: 120%;

    padding-right: 1em;
    padding-left: 1em;
    margin: auto;
    left: 0em;
    right: 0em;

    }

pre {
    background-color: #d9fcfa;
    color: #1111111;
    padding: 0.5em;
}

h1 {
     background: #ddeedd;
     text-align: center;
     border: solid;
     border-width: thin;
     border-color: green;
}

h2 {
    color: #0000ff;
    font-size: 130%;}

h3 {
    color: #0000ff;
    font-size: 120%;
}

table {
    width: 90%;
    margin-left: 5%;
    margin-right: 5%;
    table-layout: auto;
    margin-top: 1em;
    margin-bottom: 1em;
    border: 1px solid black;
    border-collapse: collapse;
}

th {
    border: 1px solid black;
    border-collapse: collapse;
    text-align: center;
    font-weight: bold;
    padding: 2px;
}

tr {
    border: 1px solid black;
    border-collapse: separate;
}

td {
    border: 1px solid black;
    text-align: left;
    padding-left: 6px;
    padding-right: 6px;
    padding-top: 8px;
    padding-bottom: 8px;

}

.box-around-text {
    border: 1px solid black;
    background: ivory;
    width: 80%;
    margin-left: auto;
    margin-right: auto;
    padding-top: 2em;
    padding-bottom: 2em;
    padding-left: 3pt;
    padding-right: 3pt;
    text-align: center;
}
*/

iframe {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: green;
}
/*
    width = 100%;
    height = 100%;
*/

div.HelpPage {
    height: 100em;
    background: red;
}

.AsideNote {
    border-style: solid;
    border-color: blue;
    background: ivory;
    padding: 1em;
}

div.AsideNote > p {
    margin-top: 0em;
    margin-bottom: 0em;
}

div.AsideNote > asidepar {
    display: block;
    margin-top: 1em;
    margin-bottom: 0em;
}

table.wordlayout {
    border: 1px solid black;
}

/*]]>*/-->
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<booktitle>Computer Systems</booktitle>
<filetitle>README-Circuits</filetitle>
<bookauthor>John T. O'Donnell</bookauthor>
<date>17 September 2023<date>
</div>
<div id="content" class="content">
<h1 class="title">Circuits for Computer Systems</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org6b2ce4b">Introduction</a></li>
<li><a href="#orge7800d6">Basic circuits</a>
<ul>
<li><a href="#orgbd261fa">Examples</a></li>
<li><a href="#org5570b86">Mux</a></li>
<li><a href="#orgcd2ee9c">Arithmetic</a></li>
<li><a href="#orga4d4500">Register</a></li>
</ul>
</li>
<li><a href="#orgc806dee">Adding new programs and circuits</a></li>
<li><a href="#org2280577">Register transfer machine</a></li>
<li><a href="#orgbf671d5">M1 processor circuit</a>
<ul>
<li><a href="#orgd6c6c0f">Quick start: running a program on the circuit</a></li>
<li><a href="#org1a52041">ALU</a></li>
<li><a href="#org2ce5235">M1 System</a></li>
<li><a href="#org4dcdd20">Object code file</a>
<ul>
<li><a href="#orgbf99e0c">Translate assembly language to object code</a></li>
<li><a href="#orgf5fef41">File naming convention</a></li>
<li><a href="#org05c2fd4">Finding the object file</a></li>
</ul>
</li>
<li><a href="#org846f251">Running the M1 processor</a></li>
<li><a href="#org0a6fe1f">An example program</a></li>
<li><a href="#org8cbf968">Reading the simulation output</a></li>
<li><a href="#org4a52793">M1 simulation driver commands</a>
<ul>
<li><a href="#org1dafe64">help</a></li>
<li><a href="#org09dac3d">quit</a></li>
<li><a href="#org6f08bfd">boot</a></li>
<li><a href="#orge0c6185">cycle (or just enter an empty command)</a></li>
<li><a href="#orgb8cefaa">regs</a></li>
<li><a href="#org11f44c5">mem a b</a></li>
<li><a href="#orgf559631">break x</a></li>
<li><a href="#org5b9b9b8">Writing simulation output to a file</a></li>
<li><a href="#org0afba40">Showing signals during DMA cycles</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org21d9838">Using ghc or ghci</a></li>
</ul>
</div>
</div>

<div id="outline-container-org6b2ce4b" class="outline-2">
<h2 id="org6b2ce4b">Introduction</h2>
<div class="outline-text-2" id="text-org6b2ce4b">
<p>
This document shows how to use the collection of examples in
<code>CompSysCode/Circuits</code>.  How those circuits work, how they are
designed, and how their simulation drivers are designed, are described
elsewhere.  Here, the focus is on how to execute the circuits using
the Hydra hardware description language.
</p>

<p>
Some of the circuits are small and simple, and there is also a full
processor circuit that can execute the programs in the
<code>CompSysCode/Programs/Sigma16/Core</code> directory.
</p>

<p>
The circuit simulations require ghc and Hydra.  For installation, see
<a href="../README-CompSysCode.html"><code>CompSysCode/README-CompSysCode.html</code></a>.
</p>

<p>
Test the installation by entering these commands, which will run a
simulation of a binary multiplier circuit:
</p>

<pre class="example" id="org0ff55b3">
cd CompSysCode/Circuits
ghc -e main Arithmetic/MultiplyRun
</pre>
</div>
</div>

<div id="outline-container-orge7800d6" class="outline-2">
<h2 id="orge7800d6">Basic circuits</h2>
<div class="outline-text-2" id="text-orge7800d6">
<p>
These small circuits are simple examples illustrating how to specify
circuits and simulation drivers.  They provide building blocks that
are used repeatedly in larger designs.  For a circuit named <code>Xyz</code>, its
simulation driver is named <code>XyzRun</code>.
</p>

<ul class="org-ul">
<li>In a <i>batch simulation</i> the driver contains the input test data.
This is convenient for repeatable testing.</li>
<li>In an <i>interactive simulation</i> the driver prompts the user for the
values of the input signals on each clock cycle.</li>
</ul>
</div>

<div id="outline-container-orgbd261fa" class="outline-3">
<h3 id="orgbd261fa">Examples</h3>
<div class="outline-text-3" id="text-orgbd261fa">
<ul class="org-ul">
<li><b><code>SimpleCirc.hs</code></b> is a small and simple circuit with just a few
logic gates.
<ul class="org-ul">
<li><code>ghc -e main Examples/SimpleCircRun</code>
<ul class="org-ul">
<li>Runs a batch simulation, using inputs defined in the driver
(<code>SimpleCircRun</code>)</li>
</ul></li>
<li><code>ghc -e main Examples/SimpleCircRunInteractive</code>
<ul class="org-ul">
<li>Run an interactive simulation that prompts the user for input
values every clock cycle.</li>
</ul></li>
</ul></li>
<li><b><code>SimDriverRun</code></b> illustrates some of the features and formatting
capabilities of a simulation driver.
<ul class="org-ul">
<li><code>ghc -e main Examples/SimDriverRun</code></li>
</ul></li>
<li><b><code>Several</code></b> shows how a simulation driver can run several
simulations in one driver file.
<ul class="org-ul">
<li><code>ghc -e main Examples/Several</code></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5570b86" class="outline-3">
<h3 id="org5570b86">Mux</h3>
<div class="outline-text-3" id="text-org5570b86">
<ul class="org-ul">
<li><b><code>mux1</code></b> is a multiplexer with 1 bit control and two input bits.
<code>mux1 c x y</code> outputs <code>x</code> if <code>c</code> is 0; otherwise it outputs <code>y</code>.  In
other words, the output is <i>(if c=0 then x else y)</i>
<ul class="org-ul">
<li><code>ghc -e main Mux/Mux1Run</code>
<ul class="org-ul">
<li>Runs a batch simulation</li>
</ul></li>
</ul></li>
<li><b><code>mux1w</code></b> is a multiplexer with 1 bit control, two input words.
Suppose <code>c</code> is an input bit, and <code>w</code> and <code>x</code> are \(n\) bit words (for
any \(n \geq 0\)). Then <code>mux2w c w x</code> outputs <code>w</code> if <code>c=0</code>, and <code>x</code> if
<code>c=1</code>.  This circuit is useful when you need to select one of two
input words.
<ul class="org-ul">
<li><code>ghc -e main Mux/Mux1wRun</code></li>
<li><code>ghc -e main Mux/Mux1wRunFormat</code>
<ul class="org-ul">
<li>Uses automatic formatting in the simulation driver</li>
</ul></li>
</ul></li>
<li><b><code>mux2w</code></b> has 2 bit control and four input words.  Suppose <code>c</code> is a
pair of bits, and <code>w</code>, <code>x</code>, <code>y</code>, <code>z</code> are all \(n\) bit words (for any
\(n \geq 0\)). Then <code>mux2w c w x y z</code> outputs <code>w</code> if <code>c=00</code>, <code>x</code> if
<code>c=01</code>, <code>y</code> if <code>c=10</code>, and <code>z</code> if <code>c=11</code>.  This circuit is useful
when you need to select one of four input words.
<ul class="org-ul">
<li><code>ghc -e main Mux/Mux2wRun</code></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcd2ee9c" class="outline-3">
<h3 id="orgcd2ee9c">Arithmetic</h3>
<div class="outline-text-3" id="text-orgcd2ee9c">
<ul class="org-ul">
<li><b><code>halfAdd</code></b> adds two bits and outputs a carry and sum.  <code>halfAdd x
  y</code> outputs <code>(c,s)</code> where <code>c</code> is the carry and <code>s</code> is the sum.
<ul class="org-ul">
<li><code>ghc -e main Arithmetic/HalfAddRun</code></li>
</ul></li>
<li><b><code>add4</code></b> 4-bit binary word adder.  It takes a carry input bit <code>c</code>
and two 4-bit words <code>x</code> and <code>y</code>.  <code>add4 c x y</code> outputs <code>(co, s)</code>
where <code>co</code> is the carry output bit, and <code>s</code> is the 4-bit sum.
<ul class="org-ul">
<li><code>ghc -e main Arithmetic/Add4Run</code></li>
</ul></li>
<li><b><code>multiply</code></b> is a sequential binary multiplier.
<ul class="org-ul">
<li><code>ghc -e main Arithmetic/MultiplyRun</code></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga4d4500" class="outline-3">
<h3 id="orga4d4500">Register</h3>
<div class="outline-text-3" id="text-orga4d4500">
<ul class="org-ul">
<li><b><code>reg1</code></b> is a register with 1-bit state.  <code>reg1 ld x</code> outputs its
state, and if <code>ld</code> is 1 it puts <code>x</code> into the state at the next clock
tick.
<ul class="org-ul">
<li><code>ghc -e main Register/Reg1Run</code>
<ul class="org-ul">
<li>Batch simulation</li>
</ul></li>
<li><code>ghc -e main Register/Reg1RunInteractive</code>
<ul class="org-ul">
<li>Interactive simulation</li>
</ul></li>
</ul></li>
<li><b><code>reg</code></b> is an \(n\) bit register.  <code>reg n ld w</code> contains a state of
\(n\) bits, receives an \(n\) bit input word <code>w</code>.  It outputs its state
(which is an \(n\) bit word), and if the <code>ld</code> input bit is 1 it puts
<code>w</code> into the state at the next clock tick.
<ul class="org-ul">
<li><code>ghc -e main Register/RegRun</code></li>
</ul></li>
<li><b><code>count4</code></b> is a 4-bit binary counter.  It is a register whose state
is an \(n\) bit word.  It takes a <code>reset</code> input bit, and contains a
4-bit state which is initially 0.  At each clock tick the counter
increments its state, but if <code>reset=1</code> it clears the state back
to 0.
<ul class="org-ul">
<li><code>ghc -e main Register/Count4Run</code></li>
</ul></li>
<li><b><code>bsr4</code></b> is a 4-bit bidirectional shift register.  It takes an
opcode which is a pair of bits that specifies what to do: 0 = no
operation; 1 = load x; 2 = shift right; 3 = shift left.  It takes a
left input <code>li</code> and a right input <code>ri</code>, and a 4-bit word <code>x</code>.  The
circuit outputs a left output, right output, and its state, and at
the next clock tick it updates its state according to the opcode.
This circuit illustrates several important circuit design
techniques.
<ul class="org-ul">
<li><code>ghc -e main Register/BSR4Run</code></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc806dee" class="outline-2">
<h2 id="orgc806dee">Adding new programs and circuits</h2>
<div class="outline-text-2" id="text-orgc806dee">
<p>
It is recommended that you put any new circuits that you define into
<code>CompSysCode/Circuits/UserCircuits</code>.  If you have a lot of them,
create a new subdirectory, something like
<code>CompSysCode/Circuits/MoreUserCircuits</code> (although with a more
descriptive name).  This will help keep your circuits separate from
the ones provided in the <code>CompSysCode</code> installation.
</p>

<p>
To make a modified version of an existing circuit, make a complete
copy of the existing directory with a new name, and edit the files in
the new directory.
</p>

<p>
For example, suppose you want to modify the <code>M1</code> processor circuit to
add a new instruction. Make a complete copy of the <code>M1</code> directory and
name it <code>M1myversion</code> (use the command <code>cp -r M1 M1myversion</code>).  Leave
the original <code>M1</code> directory unchanged, and make your changes in
<code>M1myversion</code>.
</p>

<p>
Go through each of the files in <code>M1myversion</code>, and replace <code>M1</code> by
<code>M1myversion</code> in each of the module and import statements (these
always appear at the beginning of the file).  It's important to do
this; if you don't make these changes you will import the original
<code>M1</code> code instead of your modified <code>M1myversion code</code>.  For example:
</p>
<ul class="org-ul">
<li>In <code>Control.hs</code>, change <code>module M1.Control</code> to <code>module
  M1myversion.Control</code></li>
<li>Also <code>Control.hs</code>, change <code>import M1.Interface</code> to <code>import
  M1myversion.Interface</code></li>
</ul>
<p>
Make these changes in each of the files in <code>Circuits/M1myversion</code>.
</p>

<p>
Similarly, it is recommended that you put any new programs into
<code>CompSysCode/Programs/Sigma16/Core/UserPrograms</code>.  Alternatively,
create a new subdirectory
<code>CompSysCode/Programs/Sigma16/Core/MoreUserPrograms</code>.
</p>
</div>
</div>

<div id="outline-container-org2280577" class="outline-2">
<h2 id="org2280577">Register transfer machine</h2>
<div class="outline-text-2" id="text-org2280577">
<p>
The RTM circuit contains a small array of registers, an adder, and the
ability to perform operations like <code>R1 :</code> 123= and <code>R2 :</code> R1 + R3=.
It is like a tiny processor, with only two instructions.  However, the
RTM doesn't fetch instructions from memory and decode them; its
behavior is determined entirely by its control signal inputs.  The
following will run a simulation of the RTM, using sample data
contained in the simulation driver.
</p>

<pre class="example" id="org05e7855">
ghc -e main RTM/RTMrun
</pre>
</div>
</div>

<div id="outline-container-orgbf671d5" class="outline-2">
<h2 id="orgbf671d5">M1 processor circuit</h2>
<div class="outline-text-2" id="text-orgbf671d5">
<p>
M1 is a digital circuit which is a processor for the Sigma16 Core
architecture.  It can execute all the example programs in
<code>CompSysCode/Programs/Sigma16/Core</code>.
</p>

<p>
The subsystems are defined in separate files, including the ALU,
Datapath, and Control.  The signals that communicate between the
subsystems are defined in Interface.  The processor and memory are
defined in System.  The simulation driver is defined in M1run.
</p>

<p>
There is also a utility program <code>ReadSigma16Obj.hs</code> that reads an
object code file, parses it, and generates the inputs needed to load
the code into the M1 memory.  You don't need to do anything with this
file.
</p>

<p>
The simulation driver writes two log files as the processor runs.
These log files can be deleted any time, and an old log file is
overwritten when a new simulation runs.
</p>
<ul class="org-ul">
<li><code>logCircuit.txt</code> contains the simulation driver output, showing
the internal signals and registers for each clock cycle.</li>
<li><code>logWrite.txt</code> contains text that is output by the Sigma16 program,
if any.</li>
</ul>
</div>

<div id="outline-container-orgd6c6c0f" class="outline-3">
<h3 id="orgd6c6c0f">Quick start: running a program on the circuit</h3>
<div class="outline-text-3" id="text-orgd6c6c0f">
<p>
Here is a simple example program <code>Add</code>, with comments removed.  The
assembly language source is in the file
<code>CompSysCode/Programs/Sigma16/Core/Simple/Add.asm.txt</code>.  There is also
an assembly listing file <code>Add.lst.txt</code> and an object code file
<code>Add.obj.txt</code>.
</p>

<pre class="example" id="orga636095">
   7 0000 f101 0008       load   R1,x[R0]   ; R1 := x
   8 0002 f201 0009       load   R2,y[R0]   ; R2 := y
   9 0004 0312            add    R3,R1,R2   ; R3 := x + y
  10 0005 f302 000a       store  R3,z[R0]   ; z := x + y
  11 0007 c000            trap   R0,R0,R0   ; terminate
...
  17 0008 0017      x     data  23
  18 0009 000e      y     data  14
  19 000a 0000      z     data   0
</pre>

<p>
It's a good idea first to run the program on the Sigma16 app.  Go to
the Sigma16 Home page at <a href="https://jtod.github.io/home/Sigma16/">https://jtod.github.io/home/Sigma16/</a> and
click on the link to launch the app.  Go to the <code>Examples</code> tab, select
<code>Core instruction set</code>, then <code>Simple</code>, then <code>Add.asm.txt</code>.  Go to the
<code>Assembler</code> tab and click <code>Assemble</code>, then the <code>Processor</code> tab and
click <code>Boot</code>.  This will read the object code into memory, and you can
step through the execution of the program (click <code>Step</code>), or run it to
completion (click <code>Run</code>).  See the User Guide for documentation of the
instruction set and more about how to run programs.
</p>

<p>
To run the program on the circuit, enter the following commands.
Lines beginning with <code>$</code> are shell commands, and lines beginning with
<code>M1&gt;</code> are commands to the simulation driver <code>M1run</code>.  (Don't enter the
prompts <code>$</code> or <code>M1&gt;</code>.)  The meanings of the commands are explained
below.
</p>

<pre class="example" id="orgeaa9ec2">
$ ghc -e main M1/M1run
M1&gt; boot Simple/Add
M1&gt; run
M1&gt; regs
M1&gt; mem 0 10
M1&gt; quit
$
</pre>

<ul class="org-ul">
<li><b><code>ghc -e main M1/M1run</code></b> tells the shell to run the simulation
driver.</li>
<li><b><code>boot Simple/Add</code></b> When the circuit starts, the memory contains
all 0.  This command tells the driver to read the machine language
program (<code>Add.obj.txt</code>) and store each word of object code into
memory.  This process is called <i>booting</i>.</li>
<li><b><code>run</code></b> The command starts the control algorithm, which repeatedly
fetches the next instruction and executes it.  When the program
finishes it executes a <code>trap R0,R0,R0</code> instruction to stop.  The
driver detects this and pauses the simulation.</li>
<li><b><code>regs</code></b> Now we tell the driver to print out the contents of all the
registers.  The program leaves the result, which is 37 (hex 0025),
in <code>R3</code>, and you can check that R3 has the right value.</li>
<li><b><code>mem 0 10</code></b> This prints the contents of memory from address 0000 to
000a.  (In the command, addresses are specified in decimal.)  The
program stores the final result into the variable <code>z</code>.  To find it,
we need to know the address of the variable.  Check the assembly
listing, <code>Add.lst.txt</code>, and you can see that the address of <code>z</code> is
000a.  The mem command shows that the contents of memory at that
address holds the correct result.</li>
<li><b><code>quit</code></b> Terminate the simulation driver and return to shell.</li>
</ul>
</div>
</div>

<div id="outline-container-org1a52041" class="outline-3">
<h3 id="org1a52041">ALU</h3>
<div class="outline-text-3" id="text-org1a52041">
<p>
You can run the ALU on its own with suitable test data.  This makes it
easier to test the ALU than running it as a part of the full processor
circuit.
</p>

<pre class="example" id="org97afc2f">
ghc -e main M1/ALUrun
</pre>
</div>
</div>

<div id="outline-container-org2ce5235" class="outline-3">
<h3 id="org2ce5235">M1 System</h3>
</div>

<div id="outline-container-org4dcdd20" class="outline-3">
<h3 id="org4dcdd20">Object code file</h3>
<div class="outline-text-3" id="text-org4dcdd20">
<p>
Before the processor can execute a program, that program must be
present in the memory.  This is achieved by the <code>boot</code> command: the
process of reading an object code file and writing it into memory is
called <i>booting</i> (short for <i>bootstrapping</i>).
</p>
</div>

<div id="outline-container-orgbf99e0c" class="outline-4">
<h4 id="orgbf99e0c">Translate assembly language to object code</h4>
<div class="outline-text-4" id="text-orgbf99e0c">
<p>
Computers don't run assembly language, they run machine language.  So
we need to translate the program from source code (assembly language)
to object code (machine language).  There are several ways to do this:
</p>

<ul class="org-ul">
<li><i>Sigma16 app.</i> To launch Sigma16, visit
<a href="https://jtod.github.io/home/Sigma16/">https://jtod.github.io/home/Sigma16/</a>.  Load a program (or type
it in to the editor), assemble it, and save the object code in a
file.  To see the object code, click the Object Code link in the
Assembler page.  Then copy and paste the text into a text editor and
save it.  If the source file is <code>Add.asm.txt</code>, the object file must
be named <code>Add.obj.txt</code></li>
<li><i>Command.</i> If you have installed the Sigma16 tools on your computer,
go to the <code>Programs/Sigma16/Core/Simple</code> directory and enter
<code>sigma16 assemble Add</code>.</li>
<li><i>Assemble it by hand.</i> It's important to know <i>how</i> to assemble a
program by hand, and it's worth doing one or two times.  But once
you understand how to translate from assembly to machine language,
it's better to use the software tools.  Hand assembly is
particularly useful when experimenting with new instructions in an
architecture.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf5fef41" class="outline-4">
<h4 id="orgf5fef41">File naming convention</h4>
<div class="outline-text-4" id="text-orgf5fef41">
<p>
For an assembly language module named x, there are several files
distinguished by the file extension.
</p>

<ul class="org-ul">
<li><code>x.asm.txt</code> is the assembly language source file, written by a
programmer (or a compiler).</li>
<li><code>x.obj.txt</code> is the object code file, which contains machine language
code.</li>
<li><code>x.lst.txt</code> is the assembly listing: this shows the source program,
the object code for each instruction, the symbol table, and any
error messages.</li>
<li><code>x.md.txt</code> is metadata used by the emulator; the programmer doesn't
need to do anything with this file.</li>
</ul>

<p>
An assembly language source program has a name like
<code>Simple/Add.asm.txt</code> and the corresponding object code (machine
language) file has a name like <code>Simple/Add.obj.txt</code>.  The <code>boot</code>
command uses just the base name of the file, for example <code>boot
Simple/Add</code>.
</p>
</div>
</div>

<div id="outline-container-org05c2fd4" class="outline-4">
<h4 id="org05c2fd4">Finding the object file</h4>
<div class="outline-text-4" id="text-org05c2fd4">
<p>
When the M1 simulation driver executes a <code>boot</code> command, it looks for
the object code file using a search path.  The default is to look for
the object code in the <code>CompSysCode/Programs/Sigma16/Core/</code> directory.
For example, if you enter the command <code>boot Simple/Add</code>, the driver
will look for <code>CompSysCode/Programs/Sigma16/Core/Simple/Add.obj.txt</code>.
</p>

<p>
You may wish to keep the Circuits directory and your Sigma16 programs
directory in different locations in your file system.  In this case,
it may be convenient to override the default and tell the system to
look for the object code somewhere outside <code>CompSysCode</code>.  To do so,
make a file named <code>Circuits/M1/progdir.txt</code>, and put the full file
path of the directory containing your programs in the first line of
that file.
</p>
</div>
</div>
</div>

<div id="outline-container-org846f251" class="outline-3">
<h3 id="org846f251">Running the M1 processor</h3>
<div class="outline-text-3" id="text-org846f251">
<p>
You need to be in the <code>CompSysCode/Circuits</code> directory.  The following
commands will start M1, boot an example program, and run it to
completion.  The object code must be in Sigma16 object format, which
is produced by the Sigma16 assembler.  Assembling source program
<code>Add.asm.txt</code> will produce the machine language code in <code>Add.obj.txt</code>.
</p>

<pre class="example" id="orgacb6aba">
ghc -e main M1run
M1&gt; boot Simple/Add
M1&gt; run
M1&gt; quit
</pre>

<p>
The first command (<code>ghc -e main M1run</code>) launches the M1 simulation
driver.  When the circuit starts, its memory is all 0.  To run a
machine language program we need to read in the object code file
(Simple/Add.obj.txt).  The <code>boot</code> command tells the simulation driver
to read the object file and generate the control signals needed to
write the code into memory, starting from address 0.
</p>

<p>
The run command tells the driver to execute clock cycles repeatedly,
until either a breakpoint is encountered or the program halts.
</p>

<p>
Alternatively, you can run one clock cycle simply by pressing Enter
instead of typing run.  Do this repeatedly to see how the circuit
evolves through a sequence of clock cycles.
</p>

<p>
If the object code is \(n\) words long, it will take the circuit \(n\)
clock cycles to boot it.  You can reach the point when the circuit
actually starts running the program by entering these commands.  The
<code>break reset</code> command says that <code>run</code> should stop execution when the
<code>reset</code> signal becomes 1.
</p>

<pre class="example" id="org67b2acc">
$ ghc -e main M1run
M1&gt; boot Simple/Add
M1&gt; break reset
M1&gt; run
M1&gt; quit
</pre>

<p>
Now you can step through the execution of the program: pressing Enter
will run just one clock cycle.
</p>

<p>
To run the program to completion (unless a breakpoint is set), enter
<code>run</code>.  To exit from the simulation driver and get back to the shell,
enter <code>quit</code> or <code>q</code>.
</p>

<p>
Here is a brief example of using breakpoints and register/memory
display.  The ArrayMax program finds the largest element of an array
of constant data.  The correct result is 40 decimal, which is 0028
hex.  The program leaves the result in R4, and also stores it into
<code>max</code> whose address is 0018.  By entering the <code>regs</code> command you
should see that R4=0028 and by entering <code>mem 0 30</code> you should see that
mem[0018]=0028.
</p>

<pre class="example" id="orgee5d175">
$ ghc -e main M1run
M1&gt; boot Arrays/ArrayMax
M1&gt; break reset    set breakpoint
M1&gt; run            run until reset=1
M1&gt; (enter)        run just one  clock cycle
M1 run
M1&gt; regs           print the contents of the register file
M1&gt; mem 0 30       print memory from address 0 to 30
</pre>
</div>
</div>

<div id="outline-container-org0a6fe1f" class="outline-3">
<h3 id="org0a6fe1f">An example program</h3>
<div class="outline-text-3" id="text-org0a6fe1f">
<p>
Before examining the circuit, let's begin by taking a Sigma16 assembly
language program and running it on the circuit.  This is
<code>Circuits/Programs/Add.asm.txt</code>:
</p>

<pre class="example" id="orgae5a62b">
; Add: a minimal program that adds two integer variables
; Sigma16  https://jtod.github.io/home/Sigma16

; Execution starts at location 0, where the first instruction
; will be placed when the program is executed.

      load   R1,x[R0]   ; R1 := x
      load   R2,y[R0]   ; R2 := y
      add    R3,R1,R2   ; R3 := x + y
      store  R3,z[R0]   ; z := x + y
      trap   R0,R0,R0   ; terminate

; Expected result: z = x + y = 23 + 14 = 37 (hex 0025)

; Static variables are placed in memory after the program

x     data  23
y     data  14
z     data   0
</pre>
</div>
</div>

<div id="outline-container-org8cbf968" class="outline-3">
<h3 id="org8cbf968">Reading the simulation output</h3>
<div class="outline-text-3" id="text-org8cbf968">
<p>
The driver reads the object code file and siaplays the object code,
which is a list of numbers.  Then it generates the inputs to the
circuit that will be required to boot the program.  This is a list
of strings; each string gives the input signal values for one clock
cycle.  These signals tell the circuit to perform an I/O operation
and that the operation is an external read into memory.
Furthermore, the memory address to use and the data value are
specified.  For example, the first element of the list gives the
inputs for clock cycle 0, and the last two numbers mean that the
input will store into address 0 and the value to store is 61697.
</p>

<pre class="example" id="org0ce33ca">
Object code is [61697,8,61953,9,786,62210,10,45056,23,14,0]
Boot system inputs = ["0 1 1 0 0 0 61697","0 1 1 0 0 1 8",
"0 1 1 0 0 2 61953","0 1 1 0 0 3 9","0 1 1 0 0 4 786",
"0 1 1 0 0 5 62210","0 1 1 0 0 6 10","0 1 1 0 0 7 45056",
"0 1 1 0 0 8 23","0 1 1 0 0 9 14","0 1 1 0 0 10 0"]
M1&gt;
</pre>

<p>
The purpose of the simulation driver is to show the most important of
the circuit signals, so it produces a lot of output as it runs.  Here
is a portion of the output.
</p>

<p>
The whole output
</p>

<pre class="example" id="org60ccba8">

</pre>
</div>
</div>

<div id="outline-container-org4a52793" class="outline-3">
<h3 id="org4a52793">M1 simulation driver commands</h3>
<div class="outline-text-3" id="text-org4a52793">
<p>
The simulation driver, M1run, interacts with the user through a
command line interface.  When it gives a prompt <code>M1&gt;</code> it waits for the
user to enter a command.  This section describes the M1 driver commands.
</p>
</div>

<div id="outline-container-org1dafe64" class="outline-4">
<h4 id="org1dafe64">help</h4>
<div class="outline-text-4" id="text-org1dafe64">
<p>
The <code>help</code> command prints a list of the commands.
</p>
</div>
</div>

<div id="outline-container-org09dac3d" class="outline-4">
<h4 id="org09dac3d">quit</h4>
<div class="outline-text-4" id="text-org09dac3d">
<p>
The <code>quit</code> command terminates the driver.
</p>
</div>
</div>

<div id="outline-container-org6f08bfd" class="outline-4">
<h4 id="org6f08bfd">boot</h4>
<div class="outline-text-4" id="text-org6f08bfd">
<p>
The <code>boot</code> command has one argument, a filename.  It reads the file,
which must be a valid Sigma16 object code file, and generates the
control signals needed to store the code into the memory.  The
filename is appended to the string in <code>fileprefix.txt</code>, if that file
exists.  This lets you set up a default directory for object code
files.
</p>

<p>
Suppose <code>fileprefix.txt</code> contains <code>Programs/Core</code>.  Then the following
command will boot the object program
<code>Programs/Core/Simple/Add.obj.txt</code>.
</p>

<pre class="example" id="orgd4691d3">
boot Simple/Add
</pre>

<p>
The <code>boot</code> command works by setting the circuit inputs to perform
input operations in order to store the object code.  It takes one
clock cycle for each word.  Therefore when you enter a <code>boot</code> command,
the memory won't change immediately; instead, each clock cycle causes
one more word of object code to be stored.  You can see the effect by
issueing a <code>boot</code> command, and then stepping one clock cycle at a
time.  Use the command <code>mem 0 10</code> to display the first few words of
memory.
</p>

<p>
Normally you won't want to watch the circuit signals for each clock
cycle during a <code>boot</code>.  You can set a breakpoint to stop execution
when the boot has finished, and then use <code>run</code> to simulate enough
clock cycles at full speed to complete the boot.
</p>

<pre class="example" id="org34db2b8">
boot Simple/Add
break reset
run
</pre>
</div>
</div>

<div id="outline-container-orge0c6185" class="outline-4">
<h4 id="orge0c6185">cycle (or just enter an empty command)</h4>
<div class="outline-text-4" id="text-orge0c6185">
<p>
The <code>cycle</code> command executes one clock cycle on the circuit.  At the
end of the cycle the driver displays some of the signals in the
circuit.
</p>

<p>
Just pressing enter at a driver prompt is equivalent to entering
<code>cycle</code>.  The usual way to step through a sequence of cycles is to
press enter several times.
</p>
</div>
</div>

<div id="outline-container-orgb8cefaa" class="outline-4">
<h4 id="orgb8cefaa">regs</h4>
<div class="outline-text-4" id="text-orgb8cefaa">
<p>
The simulation driver shows the values of all the output signals from
the circuit, and this includes key registers, such as <code>pc</code>, <code>ir</code>, and
<code>adr</code>.  However, most of the computer's state is in the register file
and the memory, and these are not directly visible.
</p>

<p>
If you follow all the details of every clock cycle, you can work out
the contents of the register file and the memory.  But this may be
impractical.  If you want to know what is in memory at some particular
address, there is no bound on how far back you would have to search to
find the point when something was stored in that location.
</p>

<p>
The <code>regs</code> command displays the contents of the register file.  It
doesn't take an argument.  This command generates the control signals
required to make the processor circuit read out the registers, one per
clock cycle.  The command gathers the results and prints out the
registers.  It requires one clock cycle for each register, and uses
the dma facility to read out the registers without disturbing an
executing program.
</p>

<pre class="example" id="orgdd980c0">
regs
</pre>

<p>
The <code>regs</code> and <code>mem</code> commands are not implemented by looking into the
simulator's internal data structures.  Indeed, the simulator doesn't
know anything about the circuit apart from the signal values.  The
commands are implemented by the Input/Output system, using direct
memory access (DMA) and cycle stealing.  This is the way testing is
done on real hardware.  You can see that the dump commands require a
number of clock cycles to perform, even though the driver doesn't show
all the internal signals during those cycles.
</p>
</div>
</div>

<div id="outline-container-org11f44c5" class="outline-4">
<h4 id="org11f44c5">mem a b</h4>
<div class="outline-text-4" id="text-org11f44c5">
<p>
The <code>mem a b</code> command prints the contents of memory from address \(a\)
through address \(b\).  The arguments \(a\) and \(b\) are specified as
decimal integers.  This command will print memory from address 0 to 30
decimal:
</p>

<pre class="example" id="org9f7b812">
M1&gt; mem 0 30
</pre>

<p>
The <code>mem</code> command, like <code>regs</code>, is implemented using DMA and cycle
stealing; see the <code>regs</code> section.
</p>
</div>
</div>

<div id="outline-container-orgf559631" class="outline-4">
<h4 id="orgf559631">break x</h4>
<div class="outline-text-4" id="text-orgf559631">
<p>
The machine may execute many clock cycles before it reaches a state
that you're interested in.  For example, if you want to examine
exactly how the circuit executes a jal instruction, you need to get
through the boot process and then all the instructions that execute
before the jal.  This can take a long time, and you may have to do it
repeatedly.
</p>

<p>
The M1 simulation driver provides <i>breakpoints</i> which alleviate this
problem.  The idea is that you specify that a bit signal of interest
is a breakpoint; the name of this signal is the argument <code>x</code> to the
break command.  After setting the breakpoint, you can enter a run
command.  At the start of each cycle the driver checks the signal, and
if it is 1 the driver stops the simulation and gives a prompt.  Thus
the driver will run the circuit at full speed until the breakpoint
signal becomes 1.  At that point you can examine the machine state in
detail, look at the registers or memory, step through some cycles, and
resume execution with another <code>run</code> command.
</p>

<p>
The break signal <code>x</code> cannot be any arbitrary signal; it must be
registered in advance.  The <code>help</code> command gives you a list of signals
that are registered so they can be used as a breakpoint.
</p>

<p>
One useful breakpoint signal is <code>reset</code>.  When you start the system it
may take a considerable number of clock cycles to boot the machine
language program.  You can skip over those cycles and go directly to
the point where the machine starts executing the program with the
following commands.  This will run the simulation without stopping,
until the reset signal becomes 1, and then it will stop.  That way you
can start single stepping through the program, but don't have to
single step through the boot.
</p>

<pre class="example" id="org8321664">
break reset
run
</pre>

<p>
Another useful technique is to go quickly to the point where the
machine is starting to execuate a particular instruction that you're
interested in.  The convention is that the first state of the control
algorithm for an instruction is named <code>st_instr0</code>.  For example, if
you want to watch in detail how the circuit executes a load
instruction, use these commands:
</p>

<pre class="example" id="org6f6ca65">
break st_load0
run
</pre>
</div>
</div>

<div id="outline-container-org5b9b9b8" class="outline-4">
<h4 id="org5b9b9b8">Writing simulation output to a file</h4>
<div class="outline-text-4" id="text-org5b9b9b8">
<p>
You can tell the simulation driver to copy the simulation output to a
log file by entering this command:
</p>

<pre class="example" id="org6e84688">
logging on
</pre>

<p>
The output will be saved in <code>Circuits/logCircuit.txt</code>.  The command to
turn logging back off is
</p>

<pre class="example" id="orgc51162c">
logging off
</pre>

<p>
The default is <code>logging on</code>.
</p>
</div>
</div>

<div id="outline-container-org0afba40" class="outline-4">
<h4 id="org0afba40">Showing signals during DMA cycles</h4>
<div class="outline-text-4" id="text-org0afba40">
<p>
Input/Output takes place during
</p>
<ul class="org-ul">
<li>A trap read (when the program running on M1 requests input)</li>
<li>A trap write, when the program requests output.</li>
<li>A regs command.  This tells the simulation driver to perform DMA
operations to fetch and print the contents of the register file.</li>
<li>A mem command.  This tells the driver to perform DMA operations to
fetch and display a block of words from memory.</li>
</ul>

<p>
M1 performs input/output using direct memory access (DMA) and cycle
stealing.  During I/O the normal display of all the signals for each
clock cycle is suppressed, and only the results of the actual DMA
operations are displayed.  If you want to examine all the signals,
for example in order to understand how the DMA works, enter <code>dmasigs
on</code>.  To go back to the more concise output, enter <code>dmasigs off</code>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org21d9838" class="outline-2">
<h2 id="org21d9838">Using ghc or ghci</h2>
<div class="outline-text-2" id="text-org21d9838">
<p>
The standard way to run Hydra circuit simulations is to use the ghc
command.  The <code>-e main</code> switch says to execute the main program, and
the last argument is the module to execute, which is the simulation
driver.
</p>

<pre class="example" id="org70080e0">
$ ghc -e main M1/M1run
M1&gt; boot Simple/Add
M1&gt; run
M1&gt; quit
</pre>

<p>
Instead of ghc, you can use ghci, which is an interactive Haskell
interpreter that provides some useful debugging commands.  Specify the
simulation driver with the <code>:load M1run</code> command, and then start the
driver with the <code>:main</code> command.
</p>

<pre class="example" id="orgaec5141">
$ ghci
ghci&gt; :load M1/M1run
ghci&gt; :main
M1&gt; boot Simple/Add
M1&gt; run
M1&gt; quit
ghci&gt; :quit
</pre>

<p>
The ghci command <code>:main</code> takes an optional argument which is the
object file to boot (in the example above, it's <code>Simple/Add</code>).  This
file can be omitted: just enter <code>:main</code>.  This will start the M1
driver, and at its prompt (<code>M1&gt;</code>) you can enter <code>boot Simple/Add</code>.
</p>

<pre class="example" id="org9affa13">
$         is the bash shell prompt
ghci&gt;     is the ghci prompt
M1&gt;       is the simulation driver prompt
</pre>

<p>
Here are a few useful ghci commands.  See the ghc User Guide for full
documentation.
</p>

<pre class="example" id="org1e22fff">
:r         reload after editing any of the code
uparrow    repeat previous command
:q         exit ghci, go back to shell
^C         stop and return to ghci prompt
</pre>
</div>
</div>
</div>
<div id="postamble" class="status">
<booktitle>Computer Systems</booktitle>
<filetitle>README-Circuits</filetitle>
<bookauthor>John T. O'Donnell</bookauthor>
<date>Draft Sun Sep 17 18:25:27 2023<date>
</div>
</body>
</html>